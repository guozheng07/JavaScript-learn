# Read Episode
Until now, we have been observing our JavaScript universe from the surface of our planet. We have familiarized ourselves with the values that populate our universe from a distance, but in this module, we’re changing that. We’re going to hop in a spaceship and go exploring, introducing ourselves to every value in our JavaScript universe.

Spending the time to look at each value in detail might feel unnecessary, but you can only say there are “two apples” when you clearly see that they’re two distinct apples. Distinguishing values from one another is key to understanding equality in JavaScript—which will be our next topic.

Our spaceship will guide us through the “celestial spheres” of JavaScript to meet different values. We’ll meet the primitive values first: Booleans, Numbers, Strings, and so on. Later, we’ll meet Objects and Functions. Consider it a sightseeing tour.

![image](https://user-images.githubusercontent.com/42236890/196951817-400c37cf-80c2-492b-b123-ad06243caec9.png)

## Undefined
We’ll start our tour with the Undefined type. This is a very straightforward place to start, because **there is only one value of this type**—undefined.
```
console.log(typeof(undefined)); // "undefined"
```
![image](https://user-images.githubusercontent.com/42236890/196952043-e0ca8e17-f96d-47a7-912f-1d5d6895cf8c.png)

It’s called undefined, so you might think it’s not there—but it is a value, and a very real one! Like a black hole, undefined is grumpy and can often spell trouble. For example, reading a property from it will break your program:
```
let person = undefined;
console.log(person.mood); // TypeError!
```
Oh, well. Luckily, there is only one undefined in our entire JavaScript universe. You might wonder: why does it exist at all? In JavaScript, it represents the concept of an unintentionally missing value.

You could use it in your own code by writing undefined—like you write 2 or "hello". However, undefined also commonly “occurs naturally.” It shows up in some situations where JavaScript doesn’t know what value you wanted. For example, if you forget to assign a variable, it will point to undefined:
```
let bandersnatch;
console.log(bandersnatch); // undefined
```
![image](https://user-images.githubusercontent.com/42236890/196952241-e9ed2773-140a-48aa-bfa9-a7825007f3cd.png)

Then you can point it to another value, or to undefined again if you want.

Don’t get too hung up on its name. It’s tempting to think of undefined as some kind of variable status, e.g. “this variable is not yet defined.” But that’s a completely misleading way to think about it! In fact, if you read a variable that was actually not defined (or before the let declaration), you will get an error:
```
console.log(jabberwocky); // ReferenceError!
let jabberwocky;

```
That has nothing to do with undefined.

Really, undefined is a regular primitive value, like 2 or "hello".

Handle it with care.

## Null
![image](https://user-images.githubusercontent.com/42236890/196952432-7d29b8d6-bac6-4c05-8f5d-d3dab6dc1df1.png)

The next stop on our tour is Null. You can think of null as undefined’s sister; **there is only one value of this type**—null. It behaves very similarly to undefined. For example, it will also throw a fuss when you try to access its properties:
```
let mimsy = null;
console.log(mimsy.mood); // TypeError!
```
![image](https://user-images.githubusercontent.com/42236890/196952544-1a20d179-d699-45c3-b414-7b209b9587b0.png)

**Fun Fact**

null is the only value of its own type. However, null is also a liar. Due to a bug in JavaScript, it pretends to be an object:
```
console.log(typeof(null)); // "object" (a lie!)
```
You might think this means null is an object. Don’t fall into this trap! It is a primitive value, and it doesn’t behave in any way like an object.

Unfortunately, typeof(null) is a historical accident that we’ll have to live with forever.


In practice, null is used for intentionally missing values. Why have both null and undefined? This could help you distinguish a coding mistake (which might result in undefined) from valid missing data (which you might express as null). However, this is only a convention, and JavaScript doesn’t enforce this usage. Some people avoid both of them as much as possible!

I don’t blame them.

## Booleans
![image](https://user-images.githubusercontent.com/42236890/196952870-0f3c3038-26de-43af-8254-bc6fbd72169b.png)

Next on our tour, we’ll meet booleans! Like day and night or on and off, there are only two boolean values: true and false.
```
console.log(typeof(true)); // "boolean"
console.log(typeof(false)); // "boolean"
```
We can perform logical operations with them:
```
let isSad = true;
let isHappy = !isSad; // The opposite
let isFeeling = isSad || isHappy; // Is at least one of them true?
let isConfusing = isSad && isHappy; // Are both true?
```
Before continuing our tour of the JavaScript universe, let’s check our mental model. Use the sketchpad below or a piece of paper and draw the variables (remember to think of them as wires) and the values for the above lines of code.

**Answer**
![image](https://user-images.githubusercontent.com/42236890/196953117-be607dab-e7e7-494a-8533-274e5aa8efbc.png)

First, verify that isHappy points to false, isFeeling points to true, and isConfusing points to false. (If you got different answers, there is a mistake somewhere along the way—walk through each line step by step.)

Next, verify that there is only one true and one false value on your sketch. This is important! Regardless of how booleans are stored in the memory, in our mental model there are only two of them.

## Numbers
![image](https://user-images.githubusercontent.com/42236890/196953185-0db376b0-4d08-4dde-8290-d5b2a3786984.png)

So far, we have introduced ourselves to four values: null, undefined, true, and false.

Hold on tight, as we add eighteen quintillion, four hundred and thirty-seven quadrillion, seven hundred and thirty-six trillion, eight hundred and seventy-four billion, four hundred and fifty-four million, eight hundred and twelve thousand, six hundred and twenty-four more values to our mental model!

I am, of course, talking about numbers:


